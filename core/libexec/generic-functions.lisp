;;;; -*- mode: Common-Lisp; sly-buffer-package: "yadfa"; coding: utf-8-unix; -*-
(in-package :yadfa)
(defgeneric resolve-enemy-spawn-list (element)
  (:documentation "returns the enemy-spawn-list in the hash table (enemy-spawn-list-of *game*) if a symbol or itself if a list")
  (:method ((element symbol)) (gethash element (enemy-spawn-list-of *game*)))
  (:method ((element list)) element)
  (:method ((element zone)) (resolve-enemy-spawn-list (enemy-spawn-list-of element))))
(defgeneric resolve-team-npc-spawn-list (element)
  (:documentation "returns the team-npc-spawn-list in the hash table (team-npc-spawn-list-of *game*) if a symbol or itself if a list")
  (:method ((element symbol)) (gethash element (team-npc-spawn-list-of *game*)))
  (:method ((element list)) element)
  (:method ((element zone)) (resolve-team-npc-spawn-list (team-npc-spawn-list-of element))))
(defgeneric attack (target user attack)
  (:documentation #.(f:fmt nil "Method run when attacking. @var{ATTACK} is @code{NIL} when it is the default attack without any weapons. is an instance of " (ref move :class) " when it is an attack using a move and is an instance of " (ref item :class) " when that instance is being used as a weapon"))
  (:method ((target base-character) (user base-character) (attack null))
    (declare (ignore attack))
    (let ((a (calculate-damage target user (default-attack-power-of user))))
      (format t "~a attacks ~a~%" (name-of user) (name-of target))
      (decf (health-of target) a)
      (format t "~a received ~a damage~%" (name-of target) a)
      a))
  (:method ((target base-character) (user base-character) (attack move))
    (let ((a (calculate-damage target user attack)))
      (format t "~a used ~a~%" (name-of user) (name-of attack))
      (decf (health-of target) a)
      (format t "~a received ~a damage~%" (name-of target) a)
      a))
  (:method ((target base-character) (user base-character) (item item))
    (declare (ignorable target user item))
    (let ((a (calculate-damage target user
                               (if (first (ammo-of item))
                                   (ammo-power-of (first (ammo-of item)))
                                   (power-of item)))))
      (format t "~a whacks ~a with ~a ~a~%"
              (name-of user)
              (name-of target)
              (if (malep user) "his" "her")
              (name-of item))
      (decf (health-of target) a)
      (format t "~a received ~a damage~%" (name-of target) a))))
(defgeneric battle-script (npc target)
  (:documentation #.(f:fmt nil "function that runs when it's time for @var{NPC} to attack @var{TARGET} and what @var{NPC} does to attack. Basically the \"AI\""))
  (:method ((self npc) (target base-character))
    (let ((moves-with-health
            (iter (for i in (moves-of self))
              (when (and (>= (energy-of self) (energy-cost-of i)) (position :ai-health-inc (ai-flags-of i)))
                (collect i))))
          (moves-can-use (iter (for i in (moves-of self))
                           (when (>= (energy-of self) (energy-cost-of i))
                             (collect i))))
          (move-to-use nil))
      (cond
        ((and (<= (health-of self) (/ (calculate-stat self :health) 4)) moves-with-health)
         (setf move-to-use (a:random-elt moves-with-health))
         (attack target self move-to-use))
        (t
         (when moves-can-use
           (setf move-to-use (a:random-elt moves-can-use)))
         (cond ((and moves-can-use (= (random 2) 0))
                (attack target self move-to-use)
                (decf (energy-of self) (energy-cost-of move-to-use)))
               ((wield-of self)
                (attack target self (wield-of self)))
               (t
                (attack target self nil))))))))
(defgeneric condition-script (user condition)
  (:documentation #.(f:fmt nil "Function that runs at the beginning of each turn @var{USER} is the character who has the @var{CONDITION}. @var{CONDITION} is a " (ref status-condition :class)))
  (:method ((user base-character) (condition status-condition))))
(defgeneric toggle-onesie% (onesie))
(defgeneric toggle-onesie (onesie clothes user))
;;; Wish the API I made for this wasn't so complex, but I wasn't sure how to make it simple and still retain the functionality
(defgeneric get-babyish-padding (user))
(defgeneric get-process-potty-action-type (user type had-accident))
(defgeneric output-process-potty-text (user padding type action had-accident &key stream))
