;;;; -*- mode: Common-Lisp; sly-buffer-package: "yadfa-asdf"; coding: utf-8-unix; -*-
(uiop:define-package :yadfa-asdf
  (:use :cl :iterate)
  (:export #:make #:declt-texi #:bibtex-texi))
(in-package :yadfa-asdf)
(defclass make (asdf:source-file)
  ((type :initform nil)
   (directory :initarg :directory :reader make-directory :initform nil)
   (args :initarg :args :reader args :initform nil)
   (outputs :initarg :outputs :reader outputs :initform nil)))
(defclass bibtex-texi (asdf:source-file)
  ((type :initform "bib")))
(defclass declt-texi (asdf:source-file)
  ((type :initform "declt")))
(defmethod asdf:perform ((o asdf:load-op) (c make))
  t)
(defmethod asdf:perform ((o asdf:load-op) (c bibtex-texi))
  t)
(defmethod asdf:perform ((o asdf:load-op) (c declt-texi))
  t)
(macrolet ((create-pathname (directory merge)
             `(destructuring-bind (&rest keys &key &allow-other-keys) ,directory
                (uiop:merge-pathnames* (apply 'make-pathname keys) ,merge))))
  (defmethod asdf:perform ((o asdf:compile-op) (c make))
    (uiop:run-program `(,(if (uiop:emptyp (uiop:getenv "MAKE"))
                             "make"
                             (uiop:getenv "MAKE"))
                        "-f" ,(namestring (asdf:component-pathname c))
                        "-C" ,(namestring (if (make-directory c)
                                              (create-pathname (make-directory c) (uiop:pathname-directory-pathname (asdf:component-pathname c)))
                                              (uiop:pathname-directory-pathname (asdf:component-pathname c))))
                        ,@(args c))))
  (defmethod asdf:output-files ((o asdf:compile-op) (c make))
    (let ((input (car (asdf:input-files o c))))
      (values (iter (for output in (outputs c))
                    (collect (create-pathname output (uiop:pathname-directory-pathname input))))
              t)))
  (defmethod asdf:output-files ((o asdf:compile-op) (c declt-texi))
    (let ((input (first (asdf:input-files o c))))
      (values (uiop:with-input-file (s input)
                (iter (handler-case (collect (destructuring-bind (system-name &rest keys
                                                                  &key (texi-name (if (stringp system-name)
                                                                                      system-name
                                                                                      (string-downcase system-name)))
                                                                    (texi-directory #p"./")
                                                                  &allow-other-keys)
                                                 (read s)
                                               (declare (ignore keys))
                                               (merge-pathnames (make-pathname :name texi-name :type "texi")
                                                                (if (equal #P"./" texi-directory)
                                                                    (uiop:pathname-directory-pathname input)
                                                                    texi-directory))))
                        (end-of-file () (finish)))))
              t)))
  (defmethod asdf:perform ((o asdf:compile-op) (c declt-texi))
    (let ((input (first (asdf:input-files o c)))
          (outputs (asdf:output-files o c)))
      (uiop:with-input-file (s input)
        (iter (for output in outputs)
              (handler-case (collect (destructuring-bind (system-name &rest keys &key &allow-other-keys)
                                         (read s)
                                       (let ((keys (copy-tree keys)))
                                         (setf (getf keys :texi-name) (pathname-name output))
                                         (setf (getf keys :texi-directory) (uiop:pathname-directory-pathname output))
                                         (apply 'net.didierverna.declt:declt system-name keys))))
                (end-of-file () (finish)))))))
  (defmethod asdf:output-files ((o asdf:compile-op) (c bibtex-texi))
    (let ((path (first (asdf:input-files o c))))
      (values (list (make-pathname :host (pathname-host path) :device (pathname-device path) :directory (pathname-directory path)
                                   :name (uiop:strcat (pathname-name path) ".bib")
                                   :type "texi"))
              t)))
  (defmethod asdf:perform ((o asdf:compile-op) (c bibtex-texi))
    (uiop:with-input-file (in (first (asdf:input-files o c)))
      (uiop:with-output-file (out (first (asdf:output-files o c)) :if-exists :supersede :if-does-not-exist :create)
        (let ((bibtex-runtime:*bib-database* (make-hash-table :test 'equalp))
              (*print-miser-width* 20))
          (declare (special bibtex-runtime:*bib-database*))
          (macrolet ((generate-entries ()
                       `(list
                         ,@(iter (for i in '(("author")
                                             ("title" . (format nil "@cite{~a}" this))
                                             ("date" . (multiple-value-bind (second minute hour date month year day daylight-p zone)
                                                           (decode-universal-time (date-time-parser:parse-date-time this))
                                                         (declare (ignorable second minute hour date month year day daylight-p zone))
                                                         (format nil "@abbr{~a.} ~a@comma{} ~a"
                                                                 (aref local-time:+short-month-names+ month) day year)))
                                             ("url" . (format nil "URL:@url{~a}" this))))
                                 (collect `(let ((this (bibtex-runtime:bib-entry-ref ,(car i) v)))
                                             (when this
                                               (if ',(cdr i) ,(cdr i) this))))))))
            (bibtex-runtime:read-bib-database in)
            (iter (for (k v) in-hashtable bibtex-runtime:*bib-database*)
                  (format out "@ifset ~aisref~%@item ~a @anchor{~a}~%~%~{~a.~^ ~}~%@end ifset~%" k k k
                          (iter (for i in (generate-entries))
                                (when i (collect i)))))))))))
